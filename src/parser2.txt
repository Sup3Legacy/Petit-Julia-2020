%{
  open Ast
  open Astype
  open Hyper2

%}

%token <Ast.position*int> INT
%token <Ast.position*string> CHAINE
%token <Ast.position*string> IDENT
%token EOF
%token <Ast.position> PARG
%token <Ast.position> PARD
%token <Ast.position> AFFECT
%token <Ast.position> OR
%token <Ast.position> AND
%token <Ast.position> EQ
%token <Ast.position> NEQ
%token <Ast.position> L
%token <Ast.position> G
%token <Ast.position> LEQ
%token <Ast.position> GEQ
%token <Ast.position> PLUS
%token <Ast.position> MINUS
%token <Ast.position> TIMES
%token <Ast.position> MODULO
%token <Ast.position> EXP
%token <Ast.position> NOT
%token <Ast.position> DOT

%token <Ast.position> ELSE
%token <Ast.position> ELSEIF
%token <Ast.position> END
%token <Ast.position> FALSE
%token <Ast.position> FOR
%token <Ast.position> FUNCTION
%token <Ast.position> IF
%token MUTABLE
%token <Ast.position> RETURN
%token <Ast.position> STRUCT
%token <Ast.position> TRUE
%token <Ast.position> WHILE

%token <Ast.position*int * string> ENTIER_IDENT
%token <Ast.position*string> IDENT_PARG
%token <Ast.position*int> ENTIER_PARG
%token <Ast.position*string> PARD_IDENT

%token TYPE

%token <Ast.position> COLON
%token <Ast.position> SEMICOLON
%token <Ast.position> COMMA

%token <string> DOCSTRING

%nonassoc RETURN
%right AFFECT
%left OR
%left AND
%left EQ
%left NEQ
%left L
%left G
%left LEQ
%left GEQ
%left PLUS
%left MINUS
%left TIMES
%left MODULO
%nonassoc NOT
%nonassoc unary_minus
%right EXP
%left DOT


%start fichier

%%

fichier<Ast.fichier>:
  | declarations = declarations_list {DeclarationList declarations}
;

declarations_list <Ast.declaration list>:
  | EOF {[]}
  | s = structure SEMICOLON d = declarations_list {s::d}
  | f = fonction SEMICOLON d = declarations_list {f::d}
  | e = expr SEMICOLON d = declarations_list {(Dexpr e)::d}
  | s = structure EOF {[s]}
  | f = fonction EOF {[f]}
  | e = expr EOF {[Dexpr e]}
;


structure<Ast.declaration>:
  | MUTABLE STRUCT pi = IDENT parameters = param_list
    {
      let (p,i) = pi in
      Dstruct (true, p, i, parameters)
    }
  | STRUCT pi = IDENT parameters = param_list
    {
      let (p,i) = pi in
      Dstruct (false, p, i, parameters)
    }
;

param_list<Ast.param list>:
  | END {[]}
  | SEMICOLON pl = param_list {pl}
  | p = param SEMICOLON pl = param_list {p::pl}
  | p = param END {[p]}
;

typage<string>:
  | TYPE pi = IDENT {pi}
;

fonction<Ast.declaration>:
  | FUNCTION pig = IDENT_PARG parameters = separated_list_COMMA_param
    PARD pb = bloc_END
    {
      let (p1,ig) = pig in
      let (pEnd, (p,eL)) = pb in
      Dfonction (p1,ig, parameters, p1, Any, eL, "")
    }
  | FUNCTION pig = IDENT_PARG parameters = separated_list_COMMA_param
    PARD pt = typage pb = bloc_END
    {
      let (p1,ig) = pig in
      let (pEnd, (p,eL)) = pb in
      let typ,p2 = match pt with
        | (p, "Int64") -> Int64, p
        | (p, "Bool") -> Bool, p
        | (p, "String") -> String, p
        | (p, "Any") -> Any, p
        | (p, "Nothing") -> Nothing, p
        | (p, s) -> S s, p
      in
      Dfonction (p1,ig, parameters, p2, typ, eL, "")
    }
  | FUNCTION pig = IDENT_PARG parameters = separated_list_COMMA_param
    PARD e = expr pb = bloc_END
    {
      let (p1,ig) = pig in
      let (pEnd, (p,eL)) = pb in
      Dfonction (p1,ig, parameters, p1, Any, (fst e)::eL, "")
    }
  | FUNCTION pig = IDENT_PARG parameters = separated_list_COMMA_param
    PARD pt = typage e = expr pb = bloc_END
    {
      let (p1,ig) = pig in
      let (pEnd, (p,eL)) = pb in
      let typ,p2 = match pt with
        | (p, "Int64") -> Int64, p
        | (p, "Bool") -> Bool, p
        | (p, "String") -> String, p
        | (p, "Any") -> Any, p
        | (p, "Nothing") -> Nothing, p
        | (p, s) -> S s, p
      in
      Dfonction (p1,ig, parameters, p2, typ, (fst e)::eL, "")
    }
;

separated_list_COMMA_param<Ast.param list>:
  | {[]}
  | p = param pL = separated_list_C_P {p::pL}
;

separated_list_C_P<Ast.param list>:
  | {[]}
  | COMMA p = param pL = separated_list_C_P {p::pL}
;

param<Ast.param>:
  | pi = IDENT pb = typage
    {
      let (p1,i) = pi in
      let typ,p2 = match pb with
        | (p, "Int64") -> Int64, p
        | (p, "Bool") -> Bool, p
        | (p, "String") -> String, p
        | (p, "Any") -> Any, p
        | (p, "Nothing") -> Nothing, p
        | (p, s) -> S s, p
      in
      Param (p1, i, p2, typ)
    }
  | pi = IDENT
    {
      let (p1,i) = pi in
      Param (p1, i, p1, Any)
    }
;

separated_list_COMMA_expr<Ast.expression list>:
  | {[]}
  | e = expr eL = separated_list_C_E {e::eL}
;

separated_list_C_E<Ast.expression list>:
  | {[]}
  | COMMA e = expr eL = separated_list_C_E {e::eL}
;

expr_wMin_<Ast.expression>:
  | pe1 = expr_wMin_ po = operateur pe2 = expr {
      let (p1, e1) = pe1 in
      let (p,o) = po in
      let (p2,e2) = pe2 in
      (Hyper2.fusionPos p1 p2) , Ebinop (p, o, pe1, pe2) }
  | pi = INT {let (p,i) = pi in p,Eentier i}
  | ps = CHAINE {let (p,s) = ps in p, Echaine s}
  | p = TRUE {p, Etrue}
  | p = FALSE {p, Efalse}
  | pb = ENTIER_IDENT {
  	  let (p,i,s) = pb in p, EentierIdent (p, i, s)
    }
  | pi = ENTIER_PARG pb = bloc1 p2 = PARD {
      let (p,i) = pi in
      Hyper2.fusionPos p p2, EentierParG (p, i, pb)}
  | p1 = PARG pb = bloc1 p2 = PARD { Hyper2.fusionPos p1 p2, Ebloc1 pb }
  | p1 = PARG e = expr pi = PARD_IDENT {
    let (p2,i) = pi in
    Hyper2.fusionPos p1 p2, EparDIdent (e, p2, i)}
  | pi = IDENT_PARG l = separated_list_COMMA_expr p2 = PARD {
    let (p,i) = pi in
    Hyper2.fusionPos p p2, Eapplication (p, i, l)}
  | p = NOT e = expr {Hyper2.fusionPos p (fst e), Enot e}
  | pl = expr_wMin_ AFFECT e = expr {
  		match pl with
  			|p,Elvalue l -> Hyper2.fusionPos p (fst e), ElvalueAffect (p, l, e)
  			|_ -> raise Ast.Parsing_Error
  		}
  | pl = lvalue_wMin_ {let (p,l) = pl in p, Elvalue l}
  | p = RETURN e = expr {Hyper2.fusionPos p (fst e), Ereturn (p,Some e)}
  | p = RETURN {p, Ereturn (p, None)}
  | p1 = FOR pi = IDENT AFFECT e1 = expr COLON e2b = expr_bloc p2 = END {
  		let (p,i) = pi in
  		let (e2, b) = e2b in
      Hyper2.fusionPos p1 p2, Efor ((i : ident), e1, e2, b)
    }
  | w = whileExp { w }
  | p1 = IF eb = expr_bloc pel = else_exp {
  		let (e, b) = eb in
      let (p2, el) = pel in
	    Hyper2.fusionPos p1 p2, Eif (e, b, el)
    }
;

expr_w_Ret<Ast.expression>:
  | e1 = expr po = operateur e2 = expr_w_Ret {
    let (p, o) = po in
    (Hyper2.fusionPos (fst e1) (fst e2), Ebinop (p, o, e1, e2))}
  | pi = INT {let (p,i) = pi in p, Eentier i}
  | ps = CHAINE {let (p,s) = ps in p, Echaine s}
  | p = TRUE {p, Etrue}
  | p = FALSE {p, Efalse}
  | pb = ENTIER_IDENT {
  	  let (p,i,s) = pb in p, EentierIdent (p, i, s)
    }
  | pi = ENTIER_PARG pb = bloc1 p2 = PARD {
    let (p1,i) = pi in
    (Hyper2.fusionPos p1 p2, EentierParG (p1, i, pb))}
  | p1 = PARG b = bloc1 p2 = PARD {Hyper2.fusionPos p1 p2, Ebloc1 b}
  | p1 = PARG e = expr pi = PARD_IDENT {
    let (p2,i) = pi in
    Hyper2.fusionPos p1 p2, EparDIdent (e, p2, i)}
  | pi = IDENT_PARG l = separated_list_COMMA_expr p2 = PARD {
    let (p1,i) = pi in
    Hyper2.fusionPos p1 p2, Eapplication (p1, i, l)}
  | p = NOT e = expr_w_Ret {Hyper2.fusionPos p (fst e), Enot e}
  | pl = expr AFFECT e = expr_w_Ret {
  		match pl with
  			|p, Elvalue l -> Hyper2.fusionPos p (fst e), ElvalueAffect (p, l, e)
  			| _ -> raise Ast.Parsing_Error
  		}
  | pl = lvalue {let (p,l) = pl in p, Elvalue l}
  | p1 = MINUS e = expr_w_Ret %prec unary_minus{Hyper2.fusionPos p1 (fst e),Eminus e}
  | p1 = RETURN e = expr_w_Ret {Hyper2.fusionPos p1 (fst e), Ereturn (p1, Some e)}
  | p1 = FOR pi = IDENT AFFECT e1 = expr COLON e2b = expr_bloc p2 = END {
  		let (p,i) = pi in
  		let (e2, b) = e2b in
      Hyper2.fusionPos p1 p2,	Efor ((i : ident), e1, e2, b)
    }
  | w = whileExp { w }
  | p1 = IF eb = expr_bloc pel = else_exp {
  		let (e,b) = eb in
      let (p2, el) = pel in
      Hyper2.fusionPos p1 p2, Eif (e, b, el)
    }

;

expr<Ast.expression>:
  | e1 = expr po = operateur e2 = expr {
    let (p, o) = po in Hyper2.fusionPos (fst e1) (fst e2), Ebinop (p, o, e1, e2)}
  | pi = INT {let (p,i) = pi in p, Eentier i}
  | ps = CHAINE {let (p,s) = ps in p, Echaine s}
  | p = TRUE {p, Etrue}
  | p = FALSE {p, Efalse}
  | pb = ENTIER_IDENT {
  	  let (p,i,s) = pb in p, EentierIdent (p, i, s)
    }
  | pi = ENTIER_PARG b = bloc1 p2 = PARD {
    let (p1,i) = pi in
    Hyper2.fusionPos p1 p2, EentierParG (p1, i, b)}
  | p1 = PARG b = bloc1 p2 = PARD {Hyper2.fusionPos p1 p2, Ebloc1 b}
  | p1 = PARG e = expr pi = PARD_IDENT {
    let (p2,i) = pi in
    Hyper2.fusionPos p1 p2, EparDIdent (e, p2, i)}
  | pi = IDENT_PARG l = separated_list_COMMA_expr p2 = PARD {
    let (p1,i) = pi in
    Hyper2.fusionPos p1 p2, Eapplication (p1, i, l)}
  | p = NOT e = expr {Hyper2.fusionPos p (fst e), Enot e}
  | pl = expr AFFECT e = expr {
  		match pl with
  			|p, Elvalue l -> Hyper2.fusionPos p (fst e), ElvalueAffect (p, l, e)
  			| _ -> raise Ast.Parsing_Error
  		}
  | pl = lvalue {let (p,l) = pl in p, Elvalue l}
  | p1 = MINUS e = expr %prec unary_minus {Hyper2.fusionPos p1 (fst e), Eminus e}
  | p1 = RETURN e = expr {Hyper2.fusionPos p1 (fst e), Ereturn (p1, Some e)}
  | p = RETURN {p, Ereturn (p, None)}
  | p1 = FOR pi = IDENT AFFECT e1 = expr COLON e2b = expr_bloc p2 = END {
  		let (p,i) = pi in
  		let (e2, b) = e2b in
      Hyper2.fusionPos p1 p2,	Efor ((i : ident), e1, e2, b)
    }
  | w = whileExp { w }
  | p1 = IF eb = expr_bloc pel = else_exp {
  		let (e,b) = eb in
      let (p2, el) = pel in
      Hyper2.fusionPos p1 p2, Eif (e, b, el)
    }

;

whileExp<Ast.expression>:
  | p1 = WHILE e = expr pb = bloc_END {
    let (p2,b) = pb in
    Hyper2.fusionPos p1 p2, Ewhile (e, b)}
  | p1 = WHILE e1 = expr_w_Ret e2 = expr_wMin_ pb = bloc_END {
    let (p2,(p,eL)) = pb in
    Hyper2.fusionPos p1 p2, Ewhile (e1, (Hyper2.fusionPos (fst e2) p, e2::eL))}
;

lvalue<Ast.lvalue>:
  | pi = IDENT {let (p,i) = pi in p,Lident (p,i)}
  | e = expr DOT pi = IDENT {
    let (p,i) = pi in
    Hyper2.fusionPos (fst e) p, Lindex (e, p, (i : ident))}
;

lvalue_wMin_<Ast.lvalue>:
  | pi = IDENT {let (p,i) = pi in p,Lident (p,i)}
  | e = expr_wMin_ DOT pi = IDENT {
    let (p,i) = pi in
    Hyper2.fusionPos (fst e) p, Lindex (e, p, (i : ident))}
;

else_exp<Asr.else_>:
  | p = END {p, Iend}
  | ELSE pb = bloc_END {
    let (p2, b) = pb in
    p2, Ielse b}
  | ELSE e = expr pb = bloc_END {
    let (p2, (p,b)) = pb in
    p2, Ielse (Hyper2.fusionPos (fst e) p, e::b)}
  | ELSEIF eb = expr_bloc el = else_exp {
    let (p, el) = el in
  	let (e,b) = eb in
  	p, Ielseif (e, b, el)
  	}
;

operateur<Ast.position * Ast.operateur>:
  | p = EQ {(p,Eq)}
  | p = NEQ {(p,Neq)}
  | p = L {(p,Lo)}
  | p = G {(p,Gr)}
  | p = LEQ {(p,Leq)}
  | p = GEQ {(p,Geq)}
  | p = PLUS {(p,Plus)}
  | p = MINUS {(p,Minus)}
  | p = TIMES {(p,Times)}
  | p = MODULO {(p,Modulo)}
  | p = EXP {(p,Exp)}
  | p = AND {(p,And)}
  | p = OR {(p,Or)}
;

bloc<Ast.bloc>:
  | e = expr {fst e, [e]}
  | e = expr SEMICOLON pb = bloc {
      let (p, eL) = pb in
      Hyper2.fusionPos (fst e) p, e::eL}
  | p = SEMICOLON pb = bloc {
      let (p2, eL) = pb in
      Hyper2.fusionPos p p2, eL
  }
;


expr_bloc<Ast.bloc>:
	| e = expr {(e, (fst e, []))}
	| e = expr b = expr_bloc2 {(e, b)}
	| e1 = expr_w_Ret pe2 = expr_wMin_ pb = expr_bloc2 {
    let (p1, e2) = pe2 in
    let (p2, eL) = pb in
    (e1, (Hyper2.fusionPos p1 p2, pe2::eL))}
	| e1 = expr_w_Ret pe2 = expr_wMin_ {
    let (p, e2) = pe2 in
    (e1, (p, [pe2]))}
;

expr_bloc2<Ast.bloc>:
	| p = SEMICOLON {p, []}
	| p1 = SEMICOLON e = expr pb = expr_bloc2 {
    let (p2, eL) = pb in
    Hyper2.fusionPos p1 p2, (e::eL)}
	| p1 = SEMICOLON pb = expr_bloc2 {
    let p2,eL = pb in
    Hyper2.fusionPos p1 p2, eL}
	| p = SEMICOLON e = expr {
    Hyper2.fusionPos p (fst e), [e]}
;

bloc_END<Ast.position * Ast.bloc>:
	| p = END {p,(p,[])}
	| p1 = SEMICOLON e = expr pb = bloc_END {
    let pEnd, (p2, eL) = pb in
    pEnd, (Hyper2.fusionPos p1 p2, (e::eL))
  }
	| p1 = SEMICOLON pb = bloc_END {
    let pEnd, (p2, eL) = pb in
    pEnd, (Hyper2.fusionPos p1 p2, eL)}
;

bloc1<Ast.bloc>:
  | e = expr SEMICOLON pb = bloc {
    let (p, eL) = pb in
    Hyper2.fusionPos (fst e) p, (e::eL)}
  | e = expr {(fst e), [e]}
;
